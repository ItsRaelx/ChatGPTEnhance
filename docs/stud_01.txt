01.06.2023

Algorytmy i struktury danych
Dr hab. Dariusz Barbucha, prof. UMG
Katedra SystemÃ³w Informacyjnych
Uniwersytet Morski w Gdyni
e-mail: d.barbucha@umg.edu.pl
I

O przedmiocie

O przedmiocie
Platforma
ILIAS: ilias.umg.edu.pl
Kurs: Algorytmy i Struktury Danych, 2022/2023
HasÅ‚o: â€¦

1

01.06.2023

O przedmiocie
NajogÃ³lniej
WykÅ‚ad poÅ›wiÄ™cony jest przede wszystkim algorytmicznym podejÅ›ciom
do efektywnego rozwiÄ…zywania problemÃ³w na komputerze.
Kluczowe elementy obejmujÄ… dobÃ³r â€wÅ‚aÅ›ciwychâ€:
1. Algorytmu, czyli sposobu rozwiÄ…zania
2. Struktury danych, czyli sposobu przechowywania i organizowania
danych, umoÅ¼liwiajÄ…cego wykonywanie operacji na nich, jak dostÄ™p
do danych, modyfikacja danych, itp.

O przedmiocie
Celem przedmiotu jest przedstawienie i dyskusja wybranych zagadnieÅ„
zwiÄ…zanych z:
â€¢ Podstawami analizy algorytmÃ³w, czyli majÄ…c algorytm, naleÅ¼y okreÅ›liÄ‡ co on
robi i jak efektywnie to robi (poprawnoÅ›Ä‡, zÅ‚oÅ¼onoÅ›Ä‡ obliczeniowa)
â€¢ Wybranymi technikami projektowania algorytmÃ³w, czyli majÄ…c zadanie
obliczeniowe, naleÅ¼y zaprojektowaÄ‡/dobraÄ‡ poprawny i efektywny
algorytm rozwiÄ…zujÄ…cy to zadanie
â€¢ Wybranymi algorytmami do rozwiÄ…zania waÅ¼nych zadaÅ„ (wyszukiwanie,
sortowanie, itp.)
â€¢ Podstawowymi strukturami danych, ich implementacjami i wykorzystaniem
(tablice, listy, stosy, kolejki, drzewa, grafy, itp.)
â€¢â€¦

O przedmiocie
Dlaczego warto poznaÄ‡ podstawy algorytmy i struktur danych?
â€¢ DziÄ™ki algorytmom i ich zapisowi moÅ¼emy w sposÃ³b dosyÄ‡ formalny
mÃ³wiÄ‡ o zachowaniu programÃ³w implementowanych w rÃ³Å¼nych
jÄ™zykach programowania.
â€¢ Dobry algorytm i odpowiednia struktura danych sÄ… warunkiem
powstania dobrego programu

2

01.06.2023

Literatura
Literatura podstawowa
â€¢ [CLRS-2018] T.H. Cormen, C.E. Leiserson, R.L. Rivest, C. Stein.
Wprowadzenie do algorytmÃ³w. PWN, Warszawa, 2018 (pierwsze
wydanie: 1990).
â€¢ [BDR-2018] L. Banachowski, K. Diks, W. Rytter. Algorytmy i struktury
danych. WNT, Warszawa, 2018 (pierwsze wydanie: 1996).
â€¢ [SW-2018] R. Sedgewick, K. Wayne. Algorytmy. Wyd. IV, Helion,
Gliwice, 2018.

Literatura
Literatura uzupeÅ‚niajÄ…ca
â€¢ A.V. Aho, J.E. Hopcroft, J.D. Ullman. Projektowanie i analiza
algorytmÃ³w. Helion, Gliwice, 2003.
â€¢ N. Wirth. Algorytmy + Struktury Danych = Programy. WNT,
Warszawa, 1989.
â€¢ D.E. Knuth. Sztuka programowania, tom Iâ€“III. WNT, Warszawa, 2002.
â€¢ D. Harel. Rzecz o istocie informatyki. Algorytmika. WNT, Warszawa,
1992.
â€¢ J. Bentley. PereÅ‚ki programowania. Helion, Gliwice, 2012.

ProwadzÄ…cy i zasady zaliczania
PROWADZÄ„CY:
â€¢ Dr hab. Dariusz Barbucha, prof. UMG, Katedra SystemÃ³w Informacyjnych
UMG (koordynator przedmiotu, wykÅ‚ad + laboratorium), pok. F-204, e-mail:
d.barbucha@umg.edu.pl
â€¢ Dr Arkadiusz Mirakowski, Katedra SystemÃ³w Informacyjnych UMG
(laboratorium)
â€¢ Dr hab. inÅ¼. WÅ‚odzimierz Filipowicz, prof. UMG, Katedra SystemÃ³w
Informacyjnych UMG (laboratorium), pok. F-105, e-mail:
w.filipowicz@wznj.umg.edu.pl
Zaliczenie PRZEDMIOTU:
zaliczenie wykÅ‚adu (50%) + zaliczenie laboratorium (50%)

3

01.06.2023

MateriaÅ‚y
Z uwagi na bardzo duÅ¼y walor merytoryczny i dydaktyczny, do
przygotowania wykÅ‚adu wykorzystano czÄ™Å›Ä‡ materiaÅ‚Ã³w dostÄ™pnych w
R. Sedgewick, K. Wayne. Algorytmy. Wyd. IV, Helion, Gliwice, 2018
+ materiaÅ‚y pomocnicze do tej ksiÄ…Å¼ki,
oznaczone na slajdach jako [SW-2018].

Analiza algorytmÃ³w

Zagadnienia
â€¢ Czym jest algorytm i jak go przedstawiaÄ‡?
â€¢ Co to znaczy, Å¼e algorytm jest dobry?
â€¢ Co obejmuje pojÄ™cie analizy algorytmu?
â€¢ PoprawnoÅ›Ä‡ algorytmu
â€¢ ZÅ‚oÅ¼onoÅ›Ä‡ obliczeniowa algorytmu

4

01.06.2023

Algorytmy
I. Dane jest zadanie

II. Zaprojektuj algorytm
rozwiÄ…zujÄ…cy zadanie + strukturÄ™
danych i dokonaj analizy
III. Dokonaj implementacji
algorytmu rozwiÄ…zujÄ…cego
postawione zadanie

PrzykÅ‚ady
Zadania obliczeniowe do
wykonania:
â€¢ MajÄ…c 10 liczb caÅ‚kowitych
oblicz ich sumÄ™
â€¢ SprawdÅº czy w ciÄ…gu 100
liczb caÅ‚kowitych znajduje
siÄ™ liczba 51
â€¢ MajÄ…c listÄ™ 16 miast
wojewÃ³dzkich, posortuj jÄ…
wg nazwy miasta

Algorytm
Nieformalnie,
Algorytm jest pewnÄ… Å›ciÅ›le okreÅ›lonÄ… procedurÄ… obliczeniowÄ… (ciÄ…giem
krokÃ³w), ktÃ³ra dla odpowiednich danych wejÅ›ciowych â€produkujeâ€
Å¼Ä…dane dane wyjÅ›ciowe, zwane wynikiem dziaÅ‚ania algorytmu.
StawiajÄ…c zadanie okreÅ›lamy wymagania dotyczÄ…ce relacji miÄ™dzy
danymi wejÅ›ciowymi i wyjÅ›ciowymi, natomiast algorytm opisuje
wÅ‚aÅ›ciwÄ… procedurÄ™ obliczeniowÄ…, ktÃ³ra zapewnia, Å¼e relacja ta zostanie
osiÄ…gniÄ™ta.

Algorytm
Specyfikacja algorytmu
Bardziej formalny zapis tego â€œco dokÅ‚adnie algorytm ma zrobiÄ‡â€.
Elementy specyfikacji algorytmu:
â€¢ Nazwa algorytmu + lista argumentÃ³w w nawiasach
â€¢ WejÅ›cie (warunek poczÄ…tkowy) â€“ okreÅ›la typy i dopuszczalne wartoÅ›ci
poprawnych danych wejÅ›ciowych
â€¢ WyjÅ›cie (warunek koÅ„cowy) â€“ okreÅ›la prawidÅ‚owy wynik (typ i
wartoÅ›Ä‡) jaki ma byÄ‡ zwrÃ³cony przez algorytm jako funkcja danych
wejÅ›ciowych

5

01.06.2023

Algorytm
Algorytm moÅ¼emy przedstawiÄ‡ w postaci:
â€¢ Opisu w jÄ™zyku naturalnym,
â€¢ Schematu blokowego,
â€¢ Pseudokodu,
â€¢â€¦

Algorytmy
â€Najstarszyâ€ znany/waÅ¼ny algorytm:
Algorytm Euklidesa (ok. 300 p.n.e.) wyznaczania najwiÄ™kszego
wspÃ³lnego dzielnika dla dwÃ³ch liczb naturalnych m i n â€“ NWD(m, n)
Zadanie obliczeniowe:
MajÄ…c dwie liczby naturalne m i n znajdÅº ich najwiÄ™kszy wspÃ³lny
dzielnik.

Algorytmy
Algorytm Euklidesa
Zapis w jÄ™zyku naturalnym
Podziel n przez m, niech r bÄ™dzie resztÄ… z tego dzielenia.
JeÅ¼eli r = 0 to m jest wynikiem i algorytm zatrzymuje siÄ™.
W przeciwnym przypadku podstaw: n = m, m = r i powtÃ³rz procedurÄ™.

6

01.06.2023

Algorytmy
Algorytm Euklidesa
Zapis w postaci schematu blokowego
Schemat blokowy â€“ diagram, na ktÃ³rym
algorytm jest reprezentowany przez zestaw
odpowiednich figur geometrycznych,
poÅ‚Ä…czonych liniami zgodnie z kolejnoÅ›ciÄ…
wykonywania czynnoÅ›ci wynikajÄ…cych z
przyjÄ™tego algorytmu rozwiÄ…zania zadania.

Algorytmy
Algorytm Euklidesa
Zapis w postaci pseudokodu
Pseudokod â€“ umowna notacja algorytmÃ³w
raczej abstrakcyjna/informacyjna, a nie zapis
formalny w konkretnym jÄ™zyku programowania
(brak obsÅ‚ugi bÅ‚Ä™dÃ³w, itp.). Z drugiej strony:
zapis jednoznaczny
WyglÄ…d podobny do popularnych jÄ™zykÃ³w
programowania (C/C++, Java, Python)

NWD(n, m)
{
do
{
r = n mod m
if (r == 0)
break
else
{
n = m
m = r
}
}
while (r != 0)
return m
}

Algorytm
Konwencja pseudokodu
â€¢ ZbliÅ¼ona do zapisu w jÄ™zyku Java
â€¢ â€Tradycyjneâ€, jednoznaczne symbole/opisy dla:
â€¢ LiteraÅ‚Ã³w
â€¢ Zmiennych
â€¢ OperatorÃ³w
â€¢ Instrukcji przypisania
â€¢ Instrukcji warunkowej if â€¦ then â€¦ else
â€¢ Instrukcji pÄ™tli: for, while, doâ€¦while
â€¢ Komentarze: //
â€¢ PozostaÅ‚e: funkcja(lista argumentÃ³w), return, itp.

7

01.06.2023

Algorytm
Dlaczego algorytm powinien byÄ‡ dobry?
Dobry algorytm jest niezbÄ™dny do uzyskania dobrego programu.
ale
Dobry algorytm nie gwarantuje dobrego programu.

Algorytm
Nieformalnie, dobry algorytm to algorytm, ktÃ³ry:
â€¢ RozwiÄ…zuje poprawnie zadanie dla ktÃ³rego zostaÅ‚ stworzony
â€¢ Zatrzymuje siÄ™ w skoÅ„czonej liczbie krokÃ³w
â€¢ Wykonywany wielokrotnie dla tych samych danych daje te same wyniki
â€¢ RozwiÄ…zuje zadanie w rozsÄ…dnym czasie, najlepiej: osiÄ…ga wynik przy
moÅ¼liwie minimalnym nakÅ‚adzie zasobÃ³w: czasu dziaÅ‚ania i iloÅ›ci uÅ¼ywanej
pamiÄ™ci
â€¢ RozwiÄ…zuje rÃ³Å¼ne (wszystkie?) instancje problemu, a nie pojedyncze,
specyficzne zadanie
â€¢ Jest czytelny/przejrzysty
â€¢â€¦

Algorytm
KtÃ³re cechy dobrego algorytmu sÄ… najwaÅ¼niejsze?
â€¢ PoprawnoÅ›Ä‡ -> caÅ‚kowita, czÄ™Å›ciowa
â€¢ WydajnoÅ›Ä‡ -> zÅ‚oÅ¼onoÅ›Ä‡ obliczeniowa

8

01.06.2023

PoprawnoÅ›Ä‡ algorytmu
PoprawnoÅ›Ä‡ algorytmu
OgÃ³lnie,
Algorytm jest poprawny, gdy dla kaÅ¼dego egzemplarza problemu
algorytm zatrzymuje siÄ™ i daje dobry wynik.
Czyli rozwiÄ…zuje zadany problem obliczeniowy.
Z drugiej strony, niepoprawny algorytm moÅ¼e siÄ™ nigdy nie zatrzymaÄ‡
lub po zatrzymaniu daÄ‡ zÅ‚y wynik.

PoprawnoÅ›Ä‡ algorytmu
PoprawnoÅ›Ä‡ algorytmu
Algorytm moÅ¼e byÄ‡ caÅ‚kowicie poprawny lub czÄ™Å›ciowo poprawny.
Algorytm jest caÅ‚kowicie poprawny, gdy dla wszystkich poprawnych
danych wejÅ›ciowych (czyli speÅ‚niajÄ…cych warunek wejÅ›ciowy
specyfikacji):
â€¢ zatrzymuje siÄ™ po skoÅ„czonej liczbie krokÃ³w (wÅ‚asnoÅ›Ä‡ stopu),
â€¢ zwraca poprawny wynik, tj. speÅ‚niajÄ…cy warunek koÅ„cowy specyfikacji.

PoprawnoÅ›Ä‡ algorytmu
PoprawnoÅ›Ä‡ algorytmu
Algorytm jest czÄ™Å›ciowo poprawny gdy dla poprawnych danych
wejÅ›ciowych jeÅ¼eli algorytm zatrzyma siÄ™ to zwracany jest poprawny
wynik.
Czyli czÄ™Å›ciowa poprawnoÅ›Ä‡ nie gwarantuje zatrzymania siÄ™ algorytmu.

9

01.06.2023

PoprawnoÅ›Ä‡ algorytmu
PoprawnoÅ›Ä‡ algorytmu
Zatem, chcÄ…c sprawdziÄ‡ czy algorytm jest caÅ‚kowicie poprawny szukamy
odpowiedzi na nastÄ™pujÄ…ce pytania:
1. Czy algorytm ma wÅ‚asnoÅ›Ä‡ stopu?
Zwykle nie tak bardzo skomplikowane

2. Czy zwraca poprawny wynik (jeÅ›li zatrzymuje siÄ™)?
Bardziej skomplikowane, wymaga np. podejÅ›cia z wykorzystaniem niezmiennika pÄ™tli

PoprawnoÅ›Ä‡ algorytmu
PrzykÅ‚ad 1
Specyfikacja algorytmu:
algorytm(T)
wejÅ›cie:
T â€“ tablica liczb caÅ‚kowitych
wyjÅ›cie:
liczba naturalna bÄ™dÄ…ca wartoÅ›ciÄ… maksymalnÄ…
w tablicy T

algorytm(int[] T)
{
int N = T.length()
x = T[0]
for (int i=0; i< N; i++)
{
if (T[i] > x)
{
x = T[i]
}
}
return x
}

PoprawnoÅ›Ä‡ algorytmu
PrzykÅ‚ad 2
Specyfikacja algorytmu:
algorytm(T)
wejÅ›cie:
T â€“ tablica liczb caÅ‚kowitych
wyjÅ›cie:
liczba naturalna bÄ™dÄ…ca sumÄ… wartoÅ›ci
elementÃ³w tablicy T

algorytm(int[] T)
{
int N = T.length()
sum = 0
for (int i=0; i<N; i++)
{
sum += T[i];
}
return sum
}

10

01.06.2023

PoprawnoÅ›Ä‡ algorytmu
PrzykÅ‚ad 2a
Specyfikacja algorytmu:
algorytm(T)
wejÅ›cie:
T â€“ tablica liczb caÅ‚kowitych
wyjÅ›cie:
liczba naturalna bÄ™dÄ…ca sumÄ… wartoÅ›ci
elementÃ³w tablicy T

algorytm(int[] T)
{
int N = T.length()
sum = 0
i = 0
while (i< N)
{
sum += T[i];
i++;
}
return sum
}

PoprawnoÅ›Ä‡ algorytmu
PrzykÅ‚ad 3
Specyfikacja algorytmu:
algorytm(T, x)
wejÅ›cie:
T â€“ tablica liczb caÅ‚kowitych,
x â€“ liczba caÅ‚kowita, ktÃ³rej szukamy w tablicy
wyjÅ›cie:
liczba naturalna i<N bÄ™dÄ…ca wartoÅ›ciÄ…
indeksu, pod ktÃ³rym w tablicy T wystÄ™puje
szukany element x
lub
wartoÅ›Ä‡ -1 jeÅ›li x nie wystÄ™puje w tablicy T

algorytm(int[] T, x)
{
int N = T.length()
for (int i=0; i< N; i++)
{
if (T[i] == x)
{
return i
}
}
return -1
}

ZÅ‚oÅ¼onoÅ›Ä‡ obliczeniowa algorytmu
PrzykÅ‚ad 3
Specyfikacja algorytmu:
algorytm(T, x)
wejÅ›cie:
T â€“ tablica liczb caÅ‚kowitych,
x â€“ liczba caÅ‚kowita, ktÃ³rej szukamy w tablicy
wyjÅ›cie:
liczba naturalna i<N bÄ™dÄ…ca wartoÅ›ciÄ…
indeksu, pod ktÃ³rym w tablicy T wystÄ™puje
szukany element x
lub
wartoÅ›Ä‡ -1 jeÅ›li x nie wystÄ™puje w tablicy T

algorytm(int[] T, x)
{
int N = T.length()
for (int i=0; i< N; i++)
{
if (T[i] == x)
{
return i
}
}
return -1
}

ZajmowaliÅ›my siÄ™: co dany algorytm robi?
Teraz: Jak to robi i przy jakich zasobach?

11

01.06.2023

ZÅ‚oÅ¼onoÅ›Ä‡ obliczeniowa algorytmu
ZÅ‚oÅ¼onoÅ›Ä‡ obliczeniowa algorytmu definiuje iloÅ›Ä‡ zasobÃ³w potrzebnych
do jego wykonania.
Podstawowymi zasobami rozwaÅ¼anymi w analizie algorytmÃ³w sÄ…:
â€¢ IloÅ›Ä‡ wykorzystywanej pamiÄ™ci (zÅ‚oÅ¼onoÅ›Ä‡ pamiÄ™ciowa)
â€¢ Czas dziaÅ‚ania (zÅ‚oÅ¼onoÅ›Ä‡ czasowa)

ZÅ‚oÅ¼onoÅ›Ä‡ obliczeniowa algorytmu
Od czego zaleÅ¼y iloÅ›Ä‡ wykorzystywanej pamiÄ™ci przez algorytm?
â€¢ Od typÃ³w danych zmiennych i ich reprezentacji
â€¢ Od struktur danych â€“ ich rodzaju, rozmiaru
â€¢â€¦
Typ
Bajty
Typ
Bajty
boolean

1

int[]

byte

1

double[]

8N

char

2

Date[]

40N

4N

int

4

double[][]

480NM

float

4

long

8

double

8

ZÅ‚oÅ¼onoÅ›Ä‡ obliczeniowa algorytmu
Od czego zaleÅ¼y czas dziaÅ‚ania algorytmu?
â€¢ Od zasobÃ³w sprzÄ™towych, systemowych (CPU, pamiÄ™Ä‡, itp.)
â€¦ ale rÃ³wnieÅ¼ m. in. od
â€¢ Rodzaju algorytmu dobranego do problemu (np. sortowanie przez
wstawianie vs. sortowanie szybkie)
â€¢ IloÅ›ci danych wejÅ›ciowych (sortowanie 10 vs. 1 miliona elementÃ³w), â€¦
czyli od rozmiaru problemu. Zwykle czas dziaÅ‚ania roÅ›nie wraz z rozmiarem
problemu.
â€¢ Postaci danych wejÅ›ciowych (np. stopnia posortowania ciÄ…gu wejÅ›ciowego:
juÅ¼ uporzÄ…dkowany vs. porzÄ…dek losowy)

12

01.06.2023

ZÅ‚oÅ¼onoÅ›Ä‡ obliczeniowa algorytmu
Jak mierzyÄ‡ czas dziaÅ‚ania algorytmu?
Manualnie lub automatycznie za pomocÄ… funkcji systemowych dla
wybranych instancji zaleÅ¼nych od iloÅ›ci danych, postaci danych, itp.
â€¢ Jak przenieÅ›Ä‡/uogÃ³lniÄ‡ powyÅ¼sze obserwacje na inne instancje?
â€¢ O innym rozmiarze
â€¢ O innej postaci
â€¢ â€¦

â€¢ JakÄ… przyjÄ…Ä‡ miarÄ™?

ZÅ‚oÅ¼onoÅ›Ä‡ obliczeniowa algorytmu
Obserwacja:
Miara szybkoÅ›ci algorytmu powinna byÄ‡ niezaleÅ¼na od jÄ™zyka
programowania/platformy

ZÅ‚oÅ¼onoÅ›Ä‡ obliczeniowa algorytmu
Propozycja uÅ¼ytecznej miary:
â€¢ Zliczenie podstawowych operacji wykonywanych przez algorytm.
â€¢ UzaleÅ¼nienie tej liczby od rozmiaru problemu
Ale nie wszystkich operacji, ale tzw. operacji dominujÄ…cych.
Operacje dominujÄ…ce danego algorytmu to takie operacje, ktÃ³rych
liczba jest proporcjonalna do liczby wszystkich operacji wykonanych
przez caÅ‚y algorytm.

13

01.06.2023

ZÅ‚oÅ¼onoÅ›Ä‡ obliczeniowa algorytmu
W przykÅ‚adzie 3 operacjÄ… dominujÄ…cÄ…
nie jest np.
â€¢ Instrukcja przypisania wykonywana
jednokrotnie
ale
OperacjÄ… dominujÄ…cÄ… bÄ™dzie np.
â€¢ Operacja porÃ³wnania wykonywana
wewnÄ…trz pÄ™tli

algorytm(int[] T, x)
{
int N = T.length()
for (int i=0; i< N; i++)
{
if (T[i] == x)
{
return i
}
}
return -1
}

ZÅ‚oÅ¼onoÅ›Ä‡ obliczeniowa algorytmu
ZÅ‚oÅ¼onoÅ›Ä‡ obliczeniowa algorytmu definiuje iloÅ›Ä‡ zasobÃ³w potrzebnych
do jego wykonania.
Podstawowymi zasobami rozwaÅ¼anymi w analizie algorytmÃ³w sÄ…:
â€¢ Czas dziaÅ‚ania (zÅ‚oÅ¼onoÅ›Ä‡ czasowa)
â€¢ IloÅ›Ä‡ wykorzystywanej pamiÄ™ci (zÅ‚oÅ¼onoÅ›Ä‡ pamiÄ™ciowa)

ZÅ‚oÅ¼onoÅ›Ä‡ obliczeniowa algorytmu
Zatem, podsumowujÄ…c
Jednostki w ktÃ³rych mierzymy zÅ‚oÅ¼onoÅ›Ä‡:
â€¢ zwykle sÅ‚owo pamiÄ™ci maszyny.
â€¢ zwykle wykonanie jednej operacji dominujÄ…cej.
ZÅ‚oÅ¼onoÅ›Ä‡ obliczeniowa algorytmu funkcjÄ… funkcjÄ™ rozmiaru
wejÅ›ciowych danych n. Generalnie, im wiÄ™ksze rozmiary danych
wejÅ›ciowych tym wiÄ™cej zasobÃ³w (czasu, pamiÄ™ci) jest koniecznych do
wykonania danego algorytmu.

14

01.06.2023

ZÅ‚oÅ¼onoÅ›Ä‡ obliczeniowa algorytmu
â€¢ Definicja rozmiaru danych wejÅ›ciowych zaleÅ¼y istotnie od
rozwaÅ¼anego problemu
â€¢ PrzykÅ‚ady definicji rozmiaru problemu:
â€¢ sortowanie tablicy: dÅ‚ugoÅ›Ä‡ tablicy
â€¢ problemy grafowe: iloÅ›Ä‡ wÄ™zÅ‚Ã³w i krawÄ™dzi
â€¢ operacje na wielomianach: stopieÅ„ wielomianu
â€¢ operacje na macierzach: rozmiary macierzy
â€¢ operacje arytmetyczne: caÅ‚kowita liczba bitÃ³w

ZÅ‚oÅ¼onoÅ›Ä‡ obliczeniowa algorytmu
â€¢ ZÅ‚oÅ¼onoÅ›Ä‡ czasowa to zaleÅ¼noÅ›Ä‡ pomiÄ™dzy rozmiarem danych
wejÅ›ciowych a liczbÄ… operacji elementarnych (dominujÄ…cych)
wykonywanych w trakcie przebiegu algorytmu.
â€¢ ZÅ‚oÅ¼onoÅ›Ä‡ pamiÄ™ciowa to zaleÅ¼noÅ›Ä‡ pomiÄ™dzy rozmiarem danych
wejÅ›ciowych a iloÅ›ciÄ… wykorzystanej pamiÄ™ci.

Analiza przypadkÃ³w pesymistycznego i
Å›redniego
WyrÃ³Å¼nia siÄ™:
â€¢ zÅ‚oÅ¼onoÅ›Ä‡ pesymistycznÄ… (ang. worst-case) â€“ definiowanÄ… jako iloÅ›Ä‡
zasobÃ³w komputerowych potrzebnych przy â€najgorszychâ€ danych
wejÅ›ciowych rozmiaru n.
ZÅ‚oÅ¼onoÅ›Ä‡ czasowa: jest gÃ³rnÄ… granicÄ… moÅ¼liwego czasu dziaÅ‚ania algorytmu
dla kaÅ¼dych danych wejÅ›ciowych
â€¢ zÅ‚oÅ¼onoÅ›Ä‡ oczekiwanÄ… (ang. average-case) â€“ definiowanÄ… jako iloÅ›Ä‡
zasobÃ³w komputerowych potrzebnych przy â€Å›rednichâ€ danych wejÅ›ciowych
rozmiaru n.
ZÅ‚oÅ¼onoÅ›Ä‡ czasowa: czas dziaÅ‚ania dla â€Å›rednichâ€ danych wejÅ›ciowych
(zakÅ‚adamy, Å¼e wszystkie dane wejÅ›ciowe okreÅ›lonego rozmiaru sÄ… rÃ³wnie
prawdopodobne)

15

01.06.2023

ZÅ‚oÅ¼onoÅ›Ä‡ obliczeniowa algorytmu
ÅÄ…czny czas wykonania T(N):
Suma iloczynÃ³w koszt Ã— czÄ™stotliwoÅ›Ä‡ dla wszystkich operacji.

â€¢ Ustalamy zbiÃ³r operacji.
â€¢ Koszty zaleÅ¼Ä… od zasobÃ³w maszyny.
â€¢ CzÄ™stotliwoÅ›Ä‡ wykonania zaleÅ¼y od algorytmu, danych wejÅ›ciowych.

ZÅ‚oÅ¼onoÅ›Ä‡ obliczeniowa algorytmu
int count = 0;

Operacja

for (int i = 0; i < N; i++)
if (a[i] == 0)
count++;

Deklaracja zmiennych

CzÄ™stoÅ›Ä‡
wykonania
2

Instrukcja przypisania

2

PorÃ³wnanie â€<â€

N+1

PorÃ³wnanie â€==â€

N

DostÄ™p do elementu tablicy

N

ZwiÄ™kszenie wartoÅ›ci zmiennej

N do 2N

ZÅ‚oÅ¼onoÅ›Ä‡ obliczeniowa algorytmu
int count = 0;

Operacja

for (int i = 0; i < N; i++)
for (int j = i+1; j < N; j++)
if (a[i] + a[j] == 0)
count++;

Deklaracja zmiennych
Instrukcja przypisania

CzÄ™stoÅ›Ä‡
wykonania
N+2
N+2

PorÃ³wnanie â€<â€

Â½*(N+1)(N+2)

PorÃ³wnanie â€==â€

Â½*N(N-1)

DostÄ™p do elementu tablicy

N(N-1)

ZwiÄ™kszenie wartoÅ›ci zmiennej

Â½*N(N-1)
do N(N-1)

16

01.06.2023

ZÅ‚oÅ¼onoÅ›Ä‡ obliczeniowa algorytmu
insert_sort(int[] a)
{
int N = a.length;
for (int i = 0; i < N; i++)
{
for (int j = i; j > 0; j--)
{
if (a[j] <= a[j-1])
{
int swap = a[i];
a[i] = a[j];
a[j] = swap;
}
else
break;
}
}
}

Oblicz czÄ™stoÅ›Ä‡ wykonywania
operacji w algorytmie sortowania

ZÅ‚oÅ¼onoÅ›Ä‡ obliczeniowa algorytmu
ÅÄ…czny czas wykonania T(N):
T(N) = c1*A + c2*B + c3*C + c4*D + â€¦
CzÄ™stotliwoÅ›Ä‡ operacji i ich koszt
A = dostÄ™p do tablicy (c1)
B = porÃ³wnanie liczb (c2)
C = zwiÄ™kszenie zmiennej (c3)
D = przypisanie zmiennej (c4)
â€¦

ZÅ‚oÅ¼onoÅ›Ä‡ obliczeniowa algorytmu
PrzeprowadzajÄ…c stosowne obliczenia moÅ¼emy otrzymaÄ‡ dokÅ‚adnÄ…, zÅ‚oÅ¼onÄ…
formuÅ‚Ä™ matematycznÄ….
W praktycznej analizie zÅ‚oÅ¼onoÅ›ci obliczeniowej istotniejsze jest nie
posiadanie dokÅ‚adnej postaci funkcji, a raczej rzÄ™du wielkoÅ›ci funkcji, w
ktÃ³rym:
â€¢ Zostawiamy dominujÄ…cÄ… skÅ‚adnik (np. najwyÅ¼szÄ… potÄ™gÄ™ rozmiaru problemu
w przypadku wielomianu), a ignorujemy te niÅ¼szego rzÄ™du (np. niÅ¼sze
potÄ™gi)
â€¢ Ignorujemy staÅ‚e wspÃ³Å‚czynniki
PrzykÅ‚ad: an2+bn+c -> n2

17

01.06.2023

RzÄ…d wielkoÅ›ci funkcji
RzÄ…d wielkoÅ›ci funkcji (ang. order of growth) sÅ‚uÅ¼y do opisywania
(asymptotycznego) czasu dziaÅ‚ania algorytmu.
â€¢ OkreÅ›la, jak szybko roÅ›nie funkcja, gdy roÅ›nie argument N
â€¢ Na jego podstawie moÅ¼na, np:
â€¢ scharakteryzowaÄ‡ wydajnoÅ›Ä‡ algorytmu,
â€¢ porÃ³wnaÄ‡ zÅ‚oÅ¼onoÅ›Ä‡ dwÃ³ch rÃ³Å¼nych algorytmÃ³w.

â€¢ RozwaÅ¼amy jedynie najbardziej znaczÄ…cy skÅ‚adnik w formule okreÅ›lajÄ…cej liczbÄ™
elementarnych krokÃ³w, np. an2+bn+c -> n2
Kiedy dla dostatecznie duÅ¼ych danych wejÅ›ciowych liczymy jedynie rzÄ…d wielkoÅ›ci
czasu dziaÅ‚ania algorytmu, wtedy zajmujemy siÄ™ asymptotycznÄ… zÅ‚oÅ¼onoÅ›ciÄ…
algorytmu. Interesuje nas, jak szybko wzrasta czas dziaÅ‚ania algorytmu, gdy rozmiar
danych dÄ…Å¼y do nieskoÅ„czonoÅ›ci algorytmu (asymptotyczny wzrost funkcji).

Notacja asymptotyczna (notacja â€Î˜â€)
Dla danej funkcji g(n) oznaczamy przez Î˜(g(n)) zbiÃ³r funkcji
Î˜(g(n)) = {f(n): istniejÄ… dodatnie staÅ‚e c1, c2 i n0 takie, Å¼e
0 â‰¤ c1g(n) â‰¤ f(n) â‰¤ c2 g(n) dla wszystkich nâ‰¥n0}
Formalnie f(n) Ïµ Î˜(g(n)), jednak zazwyczaj piszemy
f(n) = Î˜(g(n)).
Notacja Î˜ asymptotycznie ogranicza funkcjÄ™
od gÃ³ry oraz od doÅ‚u.

Notacja asymptotyczna (notacja â€Oâ€)
Dla danej funkcji g(n) oznaczamy przez O(g(n)) zbiÃ³r funkcji
O(g(n)) = {f(n): istniejÄ… dodatnie staÅ‚e c i n0 takie, Å¼e
0 â‰¤ f(n) â‰¤ cg(n) dla wszystkich nâ‰¥n0}
O(g(n)) zawiera siÄ™ w Î˜(g(n))
Z notacji O korzystamy po to, by oszacowaÄ‡ funkcjÄ™
z gÃ³ry (asymptotyczna granica gÃ³rna),
z dokÅ‚adnoÅ›ciÄ… do staÅ‚ego wspÃ³Å‚czynnika.
Notacja O szacuje pesymistyczny czas dziaÅ‚ania
algorytmu.

18

01.06.2023

Notacja asymptotyczna (notacja â€Î©â€)
Dla danej funkcji g(n) oznaczamy przez Î©(g(n)) zbiÃ³r funkcji
Î©(g(n)) = {f(n): istniejÄ… dodatnie staÅ‚e c i n0 takie, Å¼e
0 â‰¤ cg(n) â‰¤ f(n) dla wszystkich nâ‰¥n0}
Notacja Î© okreÅ›la asymptotycznÄ… granicÄ™ dolnÄ….
Szacuje optymistyczny czas dziaÅ‚ania algorytmu.
Î©(g(n)) zawiera siÄ™ w Î˜(g(n)).

Notacja asymptotyczna
NajczÄ™Å›ciej stosujemy
f(n) = O(g(n)),
co odczytujemy:
f(n) jest rzÄ™du g(n).
PrzykÅ‚ady
f(n) = O(n) - zÅ‚oÅ¼onoÅ›Ä‡ liniowa
f(n) = O(2n) - zÅ‚oÅ¼onoÅ›Ä‡ wykÅ‚adnicza

Notacja asymptotyczna
ğ‘‚ 1
ğ‘‚ logğ‘›
ğ‘‚ ğ‘›
ğ‘‚ ğ‘›logğ‘›
ğ‘‚(ğ‘›2)
ğ‘‚ 2ğ‘›
ğ‘‚ ğ‘›!
[http://home.agh.edu.pl/~szeliga/dydaktyka/AiSD/Materialy/main-W(Wydajnosc).pdf]

19

01.06.2023

Notacja asymptotyczna
WiÄ™kszoÅ›Ä‡ rozwaÅ¼anych algorytmÃ³w ma zÅ‚oÅ¼onoÅ›Ä‡ czasowÄ… rzÄ™du:
PostaÄ‡ funkcji g(n)

PrzykÅ‚ady algorytmÃ³w o podanej zÅ‚oÅ¼onoÅ›ci

1

operacje niezaleÅ¼ne od rozmiaru zadania, np. przypisanie

log(n) lub log n

algorytmy, w ktÃ³rych zadanie o rozmiarze n sprowadzane jest do zadania rozmiaru n/2, plus pewna staÅ‚a
liczba dziaÅ‚aÅ„ (np. wyszukiwanie binarne w uporzÄ…dkowanym ciÄ…gu

n

algorytmy, w ktÃ³rych wykonywana jest staÅ‚a liczba dziaÅ‚aÅ„ dla kaÅ¼dego z n elementÃ³w (danych
wejÅ›ciowych)

n log(n)

algorytmy, w ktÃ³rych zadanie o rozmiarze n zostaje sprowadzone do dwÃ³ch podzadaÅ„ rozmiaru n/2, plus
pewna liczba dziaÅ‚aÅ„ liniowa wzglÄ™dem rozmiaru n, potrzebna do wykonania najpierw podzielenia, a
nastÄ™pnie scalenia rozwiÄ…zaÅ„ podzadaÅ„ rozmiaru n/2 w rozwiÄ…zanie rozmiaru n

n2

algorytmy, w ktÃ³rych jest wykonywana pewna staÅ‚a liczba dziaÅ‚aÅ„ dla kaÅ¼dej pary danych wejÅ›ciowych
(podwÃ³jna iteracja)

nk

algorytmy o k wzajemnie zagnieÅ¼dÅ¼onych pÄ™tlach

2n

algorytmy, w ktÃ³rych jest wykonywana staÅ‚a liczba dziaÅ‚aÅ„ dla kaÅ¼dego podzbioru danych wejÅ›ciowych

n!

algorytmy, w ktÃ³rych jest wykonywana staÅ‚a liczba dziaÅ‚aÅ„ dla kaÅ¼dej permutacji danych wejÅ›ciowych

Notacja asymptotyczna
PrzykÅ‚ady
RzÄ…d wielkoÅ›ci
funkcji

PrzykÅ‚adowy kod

Opis

PrzykÅ‚ad

1

a = b + c;

Podstawienie wartoÅ›ci
wyraÅ¼enia

Dodawanie dwÃ³ch liczb

log(n) lub log n

while (N > 1)
{ N = N / 2; ... }

PodziaÅ‚ zadania na mniejsze o Przeszukiwanie binarne
rozmiarze N/2

n

for (int i = 0; i < N; i++)
{ ... }

PÄ™tla

ZnajdÅº maksimum

n2

for (int i = 0; i < N; i++)
for (int j = 0; j < N; j++)
{ ... }

PodwÃ³jna pÄ™tla

SprawdÅº, czy suma liczb
jest rÃ³wna 0

2n

Znalezienie wszystkich
podzbiorÃ³w

ZÅ‚oÅ¼onoÅ›Ä‡ obliczeniowa
Algorytmy o zÅ‚oÅ¼onoÅ›ci wielomianowej przyjÄ™Å‚o siÄ™ nazywaÄ‡
efektywnymi (Å‚atwymi) z punktu widzenia zÅ‚oÅ¼onoÅ›ci obliczeniowej,
algorytmy zaÅ› wykÅ‚adnicze (nie wielomianowe) â€“ nieefektywnymi
(trudnymi).
Problemy dla ktÃ³rych, prawdopodobnie, nie istniejÄ… wielomianowe
algorytmy rozwiÄ…zania nazywane sÄ… problemami NP-trudnymi.

20

01.06.2023

ZÅ‚oÅ¼onoÅ›Ä‡ obliczeniowa
PrzykÅ‚ady
â€¢ Wyszukiwanie: sekwencyjne, binarne
â€¢ Problem plecakowy
â€¢ Problem komiwojaÅ¼era
â€¢ WieÅ¼e Hanoi
â€¢â€¦

Wyszukiwanie elementu na liÅ›cie
T - tablica N liczb caÅ‚kowitych (lub np. tekstÃ³w).
Czy element x (np. 31) naleÅ¼y do tablicy T ?

4

12

9

29

43

21

11

2

Wyszukiwanie elementu na liÅ›cie

4

12

9

29

43

21

11

2

Algorytm SEARCH(x, T)
Dla kaÅ¼dego elementu od 1 do N
SprawdÅº, czy x = T[i] ?
TAK ï‚® element znaleziono, stop (â€takâ€)
NIE ï‚® weÅº nastÄ™pny element
JeÅ¼eli wyczerpiemy listÄ™ nie znajdujÄ…c elementu,
to stop (â€nieâ€)

21

01.06.2023

ZÅ‚oÅ¼onoÅ›Ä‡ algorytmu wyszukiwania elementu
na liÅ›cie
ZÅ‚oÅ¼onoÅ›Ä‡ algorytmu SEARCH wynosi O(N).
Oznacza to, Å¼e istnieje pewna staÅ‚a K, taka, Å¼e algorytm wykonuje siÄ™ w
czasie nie dÅ‚uÅ¼szym niÅ¼ K*N.
Czas wykonania roÅ›nie wiÄ™c liniowo.

Wyszukiwanie elementu na liÅ›cie
uporzÄ…dkowanej
T - tablica N liczb caÅ‚kowitych (lub np. tekstÃ³w) uporzÄ…dkowana
rosnÄ…co.
Czy element x naleÅ¼y do tablicy T ?

2

4

9

11

12

21

29

43

29

43

Wyszukiwanie elementu na liÅ›cie
uporzÄ…dkowanej
2

4

9

11

12

21

Algorytm BINSEARCH (x, T)
JeÅ¼eli T jest puste to stop (â€nieâ€)
Wybierz Å›rodkowy element tablicy T - s
x = s ï‚® stop (â€takâ€)
x > s ï‚® rozpatrz prawÄ… poÅ‚owÄ™ tablicy
x < s ï‚® rozpatrz lewÄ… poÅ‚owÄ™ tablicy

22

01.06.2023

ZÅ‚oÅ¼onoÅ›Ä‡ algorytmu wyszukiwania elementu
na liÅ›cie uporzÄ…dkowanej
W algorytmie BINSEARCH, kaÅ¼de porÃ³wnanie skraca dÅ‚ugoÅ›Ä‡ listy
(rozmiar zadania) o poÅ‚owÄ™. Zatem najwiÄ™kszÄ… moÅ¼liwÄ… liczbÄ™
porÃ³wnaÅ„ moÅ¼na wyznaczyÄ‡ obliczajÄ…c, ile razy N moÅ¼na podzieliÄ‡
przez 2 zanim otrzymamy 0. Ta liczba to log2N.
ZÅ‚oÅ¼onoÅ›Ä‡ algorytmu BINSEARCH wynosi O(logN). Notacja O(.) ukrywa
staÅ‚e czynniki, jest niezaleÅ¼na od liczby danych wejÅ›ciowych.

ZÅ‚oÅ¼onoÅ›Ä‡ algorytmu wyszukiwania elementu
na liÅ›cie uporzÄ…dkowanej
Pesymistyczna liczba porÃ³wnaÅ„ dla wyszukiwania
binarnego:
N

1+log2N

10
100

4
7

1000

10

Milion
Miliard

20
30

Miliard miliardÃ³w

60

Problem plecakowy
Dane:
SkoÅ„czony zbiÃ³r n elementÃ³w: 1,2,...n, kaÅ¼dy o okreÅ›lonym rozmiarze si
i wartoÅ›ci wi ïƒ N oraz pojemnoÅ›Ä‡ plecaka - b.
Pytanie:
KtÃ³re przedmioty naleÅ¼y zaÅ‚adowaÄ‡ do plecaka, aby zmaksymalizowaÄ‡
wartoÅ›Ä‡ zaÅ‚adowanych przedmiotÃ³w?

23

01.06.2023

Problem plecakowy

n

max ïƒ¥ wi xi
i ï€½1

n

ïƒ¥ si xi ï‚£ b
i ï€½1

xi ïƒ {0,1}

Problem plecakowy
zÅ‚oÅ¼onoÅ›Ä‡ obliczeniowa
Wektor rozwiÄ…zania: x = (x1, x2, ..., xn), xi ïƒ {0, 1}.
W najgorszym moÅ¼liwym przypadku trzeba rozpatrzyÄ‡ 2n przypadkÃ³w,
bo tyle wynosi liczba moÅ¼liwych rozwiÄ…zaÅ„.
Nie istnieje algorytm o zÅ‚oÅ¼onoÅ›ci wielomianowej.
Problem plecakowy jest problemem obliczeniowo trudnym.

Problem komiwojaÅ¼era
Dane:
C = {c1, ..., cn} - zbiÃ³r miast,
odlegÅ‚oÅ›Ä‡ dijïƒN miÄ™dzy kaÅ¼dÄ… parÄ… miast ci, (cjïƒC).
Problem:
ZnaleÅºÄ‡ najkrÃ³tszÄ… drogÄ™, Å‚Ä…czÄ…cÄ… wszystkie miasta naleÅ¼Ä…ce do C?

24

01.06.2023

Problem komiwojaÅ¼era
GdaÅ„sk (c1)
d81

Szczecin (c3)
d12

d23

BiaÅ‚ystok (c8)

d78

d34

PoznaÅ„ (c2)

Warszawa (c7)
d67

WrocÅ‚aw (c4)

Lublin (c6)

d45

d56
d12+d23+...+d78+d81 ï‚® min (?)

KrakÃ³w (c5)

Problem komiwojaÅ¼era
zÅ‚oÅ¼onoÅ›Ä‡ obliczeniowa
Wszystkich moÅ¼liwoÅ›ci przejazdu miÄ™dzy wszystkimi miastami jest
n!.
Dla 25 miast jest to liczba skÅ‚adajÄ…ca siÄ™ z 26 cyfr.
MajÄ…c komputer o zdolnoÅ›ci wykonywania miliona operacji na
sekundÄ™, czas obliczeÅ„ = 400 milionÃ³w lat.

Nie istnieje algorytm wielomianowy dla problemu komiwojaÅ¼era.
Problem komiwojaÅ¼era jest problemem obliczeniowo trudnym.

WieÅ¼e Hanoi
NaleÅ¼y przenieÅ›Ä‡ N
krÄ…Å¼kÃ³w z A na B,
byÄ‡ moÅ¼e uÅ¼ywajÄ…c
pomocniczo C.

A

B

1.

JednoczeÅ›nie
moÅ¼na przenosiÄ‡
tylko jeden krÄ…Å¼ek

2.

W Å¼adnym
momencie wiÄ™kszy
krÄ…Å¼ek nie moÅ¼e byÄ‡
umieszczony na
krÄ…Å¼ku mniejszym.

C

RozwiÄ…zanie:
Aï‚®B, Aï‚®C, Bï‚®C, Aï‚®B, Cï‚®A, Cï‚®B, Aï‚®B

25

01.06.2023

WieÅ¼e Hanoi
algorytm
Algorytm PRZENIEÅš N z A na B uÅ¼ywajÄ…c C
1. JeÅ›li N = 1 to wypisz â€Xï‚®Yâ€
2. W przeciwnym razie (tj. gdy N > 1) wykonaj:
2.1 wywoÅ‚aj PRZENIEÅš N-1 z A na C uÅ¼ywajÄ…c B
2.2 wypisz â€Xï‚®Yâ€
2.3 wywoÅ‚aj PRZENIEÅš N-1 z C na B uÅ¼ywajÄ…c A
3. WrÃ³Ä‡

WieÅ¼e Hanoi
zÅ‚oÅ¼onoÅ›Ä‡ obliczeniowa
Liczba M(N) pojedynczych przeniesieÅ„ krÄ…Å¼ka, wyznaczona przez
algorytm dla przypadku N krÄ…Å¼kÃ³w wynosi dokÅ‚adnie 2N-1.
Zatem zÅ‚oÅ¼onoÅ›Ä‡ obliczeniowa tego algorytmu wynosi O(2N) â€“ jest to
zÅ‚oÅ¼onoÅ›Ä‡ wykÅ‚adnicza.

WieÅ¼e Hanoi
zÅ‚oÅ¼onoÅ›Ä‡ obliczeniowa
Oryginalna wersja tybetaÅ„ska polegaÅ‚a na przeniesieniu 64 krÄ…Å¼kÃ³w.
Wynalazcy tej Å‚amigÅ‚Ã³wki nie byli caÅ‚kiem oderwani od rzeczywistoÅ›ci,
gdy oÅ›wiadczali, Å¼e koniec Å›wiata nastÄ…pi wtedy, gdy wszystkie krÄ…Å¼ki
bÄ™dÄ… przeniesione.
1 krÄ…Å¼ek co 10 sekund - piÄ™Ä‡ bilionÃ³w lat pracy.
1 milion krÄ…Å¼kÃ³w na sekundÄ™ â€“ pÃ³Å‚ miliona lat.

26

01.06.2023

Podsumowanie

27


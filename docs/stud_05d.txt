01.06.2023

Tablice z haszowaniem
PrzykÅ‚ad
W dalszym ciÄ…gu operujemy na parze (klucz, wartoÅ›Ä‡).
ZaÅ‚Ã³Å¼my, Å¼e mamy tablicÄ™ T, w ktÃ³rej:
â€¢ Indeks jest kluczem - i
â€¢ W tablicy pod tym indeksem jest wartoÅ›Ä‡, czyli T[i] zawiera wartoÅ›Ä‡
skojarzonÄ… z i.
Mamy zatem zapewniony bezpoÅ›redni dostÄ™p do wartoÅ›ci poprzez klucz,
ale â€¦ uwaga: rÃ³wnowaga czasu i pamiÄ™ci.

Tablice z haszowaniem
Haszowanie
Metoda, w ktÃ³rej pary (klucz, wartoÅ›Ä‡) w tablicach wskazywane sÄ… na
podstawie operacji arytmetycznych przeksztaÅ‚cajÄ…cych klucze w indeksy
tablicy.
Pozwala ograniczyÄ‡ do rozsÄ…dnej iloÅ›ci potrzebny czas i pamiÄ™Ä‡. W
algorytmach haszowania moÅ¼na zyskaÄ‡ czas kosztem pamiÄ™ci (i na
odwrÃ³t) dostosowujÄ…c odpowiednio parametry, nie modyfikujÄ…c kodu.

Tablice z haszowaniem
Algorytmy wyszukiwania oparte na haszowaniu skÅ‚adajÄ… siÄ™ generalnie z
dwÃ³ch krokÃ³w:
1. Obliczenie wartoÅ›ci funkcji haszujÄ…cej, ktÃ³ra przeksztaÅ‚ca klucz
wyszukiwania na skrÃ³t wyznaczajÄ…cy indeks tablicy (zakÅ‚ada siÄ™/ dÄ…Å¼y
siÄ™ to sytuacji, Å¼e rÃ³Å¼ne klucze odpowiadajÄ… rÃ³Å¼nym indeksom, ale
nie zawsze tak jest).
2. RozwiÄ…zywanie ew. kolizji
a) Haszowanie metodÄ… Å‚aÅ„cuchowÄ…
b) Haszowanie z wykorzystaniem prÃ³bkowania liniowego

1

01.06.2023

Tablice z haszowaniem
Funkcje haszujÄ…ce
ZakÅ‚adajÄ…c, Å¼e istnieje tablica mieszczÄ…ca M par (klucz, wartoÅ›Ä‡),
potrzebna jest funkcja haszujÄ…ca, ktÃ³ra potrafi przeksztaÅ‚ciÄ‡ dowolny
klucz na indeks tej tablicy, czyli [0, M-1].
Szukamy zatem funkcji, ktÃ³ra byÅ‚aby Å‚atwa do obliczenia i zapewniaÅ‚aby
rÃ³wnomierny rozkÅ‚ad kluczy. Czyli dla kaÅ¼dego klucza wystÄ…pienie
dowolnej liczby caÅ‚kowitej z przedziaÅ‚u 0 do M-1 powinno byÄ‡ tak samo
prawdopodobne.

Tablice z haszowaniem
Funkcje haszujÄ…ce
Funkcja haszujÄ…ca zaleÅ¼y od typu klucza, czyli dla kaÅ¼dego uÅ¼ywanego
typu klucza potrzebna jest inna funkcja haszujÄ…ca, przykÅ‚adowo:
â€¢ Numer albumu czy teÅ¼ PESEL moÅ¼na zwykle uÅ¼yÄ‡ bezpoÅ›rednio
â€¢ Nazwisko naleÅ¼aÅ‚oby zamieniÄ‡ najpierw na liczbÄ™
â€¢ Inne typy zÅ‚oÅ¼one, skÅ‚adajÄ…ce siÄ™ z kilku pÃ³l, np. adres pocztowy â€“
trzeba je w pewien sposÃ³b poÅ‚Ä…czyÄ‡

Tablice z haszowaniem
Funkcje haszujÄ…ce
Dodatnie liczby caÅ‚kowite
Najbardziej popularny sposÃ³b (zwany haszowaniem modularnym):
Wybieramy rozmiar tablicy M â€“ liczba pierwsza, a nastÄ™pnie dla
dowolnej liczby dodatniej caÅ‚kowitej k obliczamy resztÄ™ z dzielenia k
przez M (w Javie: k % M ).
Funkcja jest skuteczna w rozÅ‚oÅ¼eniu kluczy rÃ³wnomiernie pomiÄ™dzy 0 a
M-1.
JeÅ›li M nie byÅ‚aby liczbÄ… pierwszÄ… â€“ niemoÅ¼liwym moÅ¼e staÄ‡ siÄ™
rÃ³wnomierny podziaÅ‚ wartoÅ›ci.

2

01.06.2023

Tablice z haszowaniem
Funkcje haszujÄ…ce
Liczby zmiennoprzecinkowe
JeÅ›li kluczami sÄ… liczby rzeczywiste z przedziaÅ‚u od 0 do 1, moÅ¼na
pomnoÅ¼yÄ‡ je przez M i zaokrÄ…gliÄ‡ do najbliÅ¼szej liczby caÅ‚kowitej, aby
uzyskaÄ‡ indeks z przedziaÅ‚u od 0 do M-1.
WadÄ… jest to, iÅ¼ nadaje wiÄ™kszÄ… wagÄ™ znaczÄ…cym bitom klucza, te mniej
znaczÄ…cÄ… nie liczÄ… siÄ™. ObejÅ›ciem moÅ¼e byÄ‡ wykorzystanie haszowania
modularnego na binarnej reprezentacji klucza (zastosowano w Javie).

Tablice z haszowaniem
Funkcje haszujÄ…ce
ÅaÅ„cuchy znakÃ³w
Wykorzystujemy fakt, iÅ¼ Å‚aÅ„cuch znakÃ³w traktowany moÅ¼e byÄ‡ jako duÅ¼a liczba
caÅ‚kowita.
PrzykÅ‚ad obliczenia wartoÅ›ci funkcji haszujÄ…cej dla Å‚aÅ„cucha s typu String:
int h = 0;
for (int i = 0; i < s.length(); i++)
h = (R * h + s.charAt(i)) % M;

charAt(i) â€“ zwraca wartoÅ›Ä‡ typu char, czyli 16-bitowÄ… liczbÄ™ caÅ‚kowitÄ….
R â€“ maÅ‚a liczba pierwsza (w Javie jest to 31).

Tablice z haszowaniem
Funkcje haszujÄ…ce
Klucze zÅ‚oÅ¼one
JeÅ›li klucz obejmuje kilka pÃ³l caÅ‚kowitoliczbowych, zwykle moÅ¼emy je
poÅ‚Ä…czyÄ‡ podobnie jak przy Å‚aÅ„cuchach znakÃ³w.
ZaÅ‚Ã³Å¼my, Å¼e mamy typ Date, obejmujÄ…cy trzy pola day (dwie cyfry),
month (dwie cyfry) i year (cztery cyfry). WartoÅ›Ä‡ obliczamy jako:
int h = (((day * R + month) % M) * R + year) % M

Uzyskana wartoÅ›Ä‡ to liczba z caÅ‚kowita z przedziaÅ‚u od 0 do M-1.

3

01.06.2023

Tablice z haszowaniem
Funkcje haszujÄ…ce
Implementacja w Javie
Wszystkie klasy w Javie dziedziczÄ… metodÄ™ int hashCode(), ktÃ³ra
zwraca liczbÄ™ 32 bitowÄ….
â€¢ WymÃ³g: jeÅ›li x.equals(y), to
(x.hashCode()==y.hashCode()).
â€¢ PoÅ¼Ä…dane: !x.equals(y), to
(x.hashCode()!=y.hashCode()).
â€¢ DomyÅ›lnie zwraca adres maszynowy obiektu x.
â€¢ Dla typÃ³w Integer, Double, String, File, URL, Date,
â€¦, Java udostÄ™pnia implementacje metody hashCode()

Tablice z haszowaniem
Funkcje haszujÄ…ce
Implementacja w Javie
Jak przeksztaÅ‚ciÄ‡ wartoÅ›Ä‡ funkcji hashCode() na indeks tablicy z
przedziaÅ‚u od 0 do M-1?
ÅÄ…czymy wartoÅ›Ä‡ funkcji hashCode() z haszowaniem modularnym:
private int hash(Key key) {
return (key.hashCode() & 0x7fffffff) % M;
}

Tablice z haszowaniem
Funkcje haszujÄ…ce
Implementacja w Javie
hashCode() definiowana przez uÅ¼ytkownika
Oczekuje siÄ™, Å¼e funkcja hashCode() rozkÅ‚ada rÃ³wnomiernie pomiÄ™dzy
moÅ¼liwe 32-bitowe wartoÅ›ci. Oznacza to, Å¼e dla dowolnego obiektu x
moÅ¼na zapisaÄ‡ x.hashCode() oczekiwaÄ‡ z rÃ³wnym
prawdopodobieÅ„stwem jednej z 232 moÅ¼liwych 32-bitowych wartoÅ›ci.

4

01.06.2023

Tablice z haszowaniem
Funkcje haszujÄ…ce
Implementacja w Javie
hashCode() definiowana przez uÅ¼ytkownika
Trzy podstawowe wymagania przy implementacji dobrej funkcji
haszujÄ…cej dla okreÅ›lonego typu danych:
â€¢ Determinizm â€“ rÃ³wne klucze muszÄ… dawaÄ‡ takÄ… samÄ… wartoÅ›Ä‡ funkcji
haszujÄ…cej.
â€¢ DziaÅ‚anie wydajne.
â€¢ RÃ³wnomiernie rozdzielanie kluczy.

Tablice z haszowaniem
Funkcje haszujÄ…ce
ZaÅ‚oÅ¼enie o rÃ³wnomiernym haszowaniu
Funkcje haszujÄ…ce rÃ³wnomiernie i niezaleÅ¼nie rozdzielajÄ… klucze miÄ™dzy
caÅ‚kowitoliczbowe wartoÅ›ci z przedziaÅ‚u od 0 do M-1.

Tablice z haszowaniem
Haszowanie metodÄ… Å‚aÅ„cuchowÄ… (ang. separate chaining)
Drugim krokiem algorytmÃ³w haszowania jest rozwiÄ…zywanie kolizji, czyli
sytuacji, w ktÃ³rej dla dwÃ³ch lub wiÄ™cej kluczy funkcja haszujÄ…ca wskazuje
na ten sam indeks w tablicy.

5

01.06.2023

Tablice z haszowaniem
Haszowanie metodÄ… Å‚aÅ„cuchowÄ…
Proste rozwiÄ…zanie:
â€¢ Utrzymujemy tablicÄ™ M elementowÄ…
(indeksy: 0 ... M-1) do przechowania
N par (klucz, wartoÅ›Ä‡).
â€¢ Dla kaÅ¼dego indeksu i utrzymujemy
listÄ™ powiÄ…zanÄ… par, dla ktÃ³rych
funkcja haszujÄ…ca zwraca indeks i.
JeÅ¼eli dla danego klucza znajdziemy
indeks pozostanie do przeszukania
tylko lista (Å‚aÅ„cuch) przypisana do tego
indeksu.
[SW-2018]

Tablice z haszowaniem
Haszowanie metodÄ… Å‚aÅ„cuchowÄ…
Implementacja

public class SeparateChainingHashST <Key, Value>
{
private int M = 97;
private Node[] st = new Node[M];
private static class Node {
private Object key;
private Object val;
private Node next;
}
private int hash(Key key) {
return (key.hashCode() & 0x7fffffff) % M;
}
public Value get(Key key) {
}
public void put(Key key, Value val) {
}
}

Tablice z haszowaniem
Haszowanie metodÄ… Å‚aÅ„cuchowÄ…
Implementacja

public class SeparateChainingHashST <Key, Value>
{
â€¦
public Value get(Key key) {
int i = hash(key);
for (Node x = st[i]; x != null; x = x.next)
if (key.equals(x.key))
return (Value) x.val;
return null;
}
public void put(Key key, Value val) {
int i = hash(key);
for (Node x = st[i]; x != null; x = x.next)
if (key.equals(x.key)) {
x.val = val;
return;
}
st[i] = new Node(key, val, st[i]);
}
â€¦

}

6

01.06.2023

Tablice z haszowaniem
Haszowanie metodÄ… Å‚aÅ„cuchowÄ…
Implementacja

public class SeparateChainingHashST <Key, Value>
{
â€¦
public Value delete(Key key) {
â€¦
}

public int size() {
â€¦
}
}

Tablice z haszowaniem
Haszowanie metodÄ… Å‚aÅ„cuchowÄ…
Jakie wybraÄ‡ M?
â€¢ JeÅ¼eli M za duÅ¼e â‡’ zbyt wiele pustych Å‚aÅ„cuchÃ³w.
â€¢ JeÅ¼eli M za maÅ‚e â‡’ Å‚aÅ„cuchy sÄ… zbyt dÅ‚ugie.
â€¢ Typowy wybÃ³r: M ~ N / 4.

Tablice z haszowaniem
Haszowanie metodÄ…
Å‚aÅ„cuchowÄ…
Celem jest aby Å›rednia dÅ‚ugoÅ›Ä‡
listy N/M byÅ‚a staÅ‚a.
Zmiana wielkoÅ›ci tablicy:
â€¢ Podwajamy wielkoÅ›Ä‡ tablicy M
gdy N/M â‰¥ 8.
â€¢ Zmniejszamy dwukrotnie
wielkoÅ›Ä‡ tablicy M gdy N/M â‰¤
2.
â€¢ Uwaga: wymagane jest rehaszowanie wszystkich kluczy.

przed

po

[SW-2018]

7

01.06.2023

Tablice z haszowaniem
CASE WORST CASE WORST CASE
HaszowanieWORST
metodÄ…
Å‚aÅ„cuchowÄ…
Wyszukanie
Wstawienie
Usuwanie

Implementacja

AVG CASE
Wyszukanie

AVG CASE
Wstawienie

AVG CASE
Usuwanie

PorÃ³wnanie
kluczy

Przeszukiwanie
sekwencyjne w tablicy
symboli (lista powiÄ…zana
nieuporzÄ…dkowana)

N

N

N

N/2

N

N/2

equals()

Przeszukiwanie binarne
w tablicy symboli
(tablica
uporzÄ…dkowana)

log N

N

N

log N

N/2

N/2

compareTo()

Drzewa wyszukiwaÅ„
binarnych

N

N

N

1.39 log N

1.39 log N

ğ‘

compareTo()

Drzewa 2-3
Czerwono-czarne BST

2 log N

2 log N

2 log N

1.00 log N

1.00 log N

1.00 log N

compareTo()

Haszowanie metodÄ…
Å‚aÅ„cuchowÄ…

N

N

N

3-5

3-5

3-5

Tablice z haszowaniem
Haszowanie metodÄ… liniowego prÃ³bkowania (ang. linear probing)
â€¢ Utrzymujemy tablicÄ™ M elementowÄ… (indeksy: 0 ... M-1) do
przechowania N par (klucz, wartoÅ›Ä‡), gdzie M > N.
â€¢ Dla kaÅ¼dego indeksu i utrzymujemy listÄ™ powiÄ…zanÄ… par (klucz,
wartoÅ›Ä‡), dla ktÃ³rych funkcja haszujÄ…ca zwraca indeks i.
â€¢ ZakÅ‚adamy, Å¼e puste miejsca w tablicy wykorzystamy przy
rozwiÄ…zywaniu kolizji, czyli jeÅ›li stwierdzimy kolizjÄ™, szukamy
nastÄ™pnego indeksu (dokonujemy jego zwiÄ™kszenia).

Tablice z haszowaniem
Haszowanie metodÄ… liniowego prÃ³bkowania
Mamy trzy moÅ¼liwoÅ›ci:
â€¢ Klucz jest rÃ³wny kluczowi wyszukiwania â€“ wyszukiwanie udane
â€¢ Pozycja jest pusta, czyli na pozycji o danym indeksie jest null â€“
wyszukiwanie jest nieudane
â€¢ Klucz nie jest rÃ³wny kluczowi wyszukiwania â€“ naleÅ¼y sprawdziÄ‡
nastÄ™pnÄ… pozycjÄ™.

8

01.06.2023

Tablice z haszowaniem
Haszowanie metodÄ… liniowego prÃ³bkowania

[SW-2018]

Tablice z haszowaniem
Haszowanie metodÄ… liniowego
prÃ³bkowania
Implementacja

public class LinearProbingHashST <Key, Value>
{
private int M;
private Value[] vals = (Value[]) new Object[M];
private Key[] keys = (Key[]) new Object[M];
private int hash(Key key) {
}
public Value get(Key key) {
}
public void put(Key key, Value val) {
}
}

Tablice z haszowaniem
Haszowanie metodÄ… liniowego
prÃ³bkowania
Implementacja

public class LinearProbingHashST <Key, Value>
{
â€¦
public Value get(Key key) {
for (int i = hash(key); keys[i] != null;
i = (i+1) % M)
if (key.equals(keys[i]))
return vals[i];
return null;
}
public void put(Key key, Value val) {
int i;
for (i = hash(key); keys[i] != null;
i = (i+1) % M)
if (keys[i].equals(key))
break;
keys[i] = key;
vals[i] = val;
}
â€¦

}

9

01.06.2023

Tablice z haszowaniem
Haszowanie metodÄ… liniowego prÃ³bkowania
Celem jest aby Å›rednia dÅ‚ugoÅ›Ä‡ listy N/M <= Â½.
Zmiana wielkoÅ›ci tablicy:
â€¢ Podwajamy wielkoÅ›Ä‡ tablicy M gdy N/M â‰¥ Â½ .
â€¢ Zmniejszamy dwukrotnie wielkoÅ›Ä‡ tablicy M gdy N/M â‰¤ 1/8.
â€¢ Uwaga: wymagane jest re-haszowanie wszystkich kluczy.

Tablice z haszowaniem
CASE WORST CASE WORST CASE
AVG CASE
HaszowanieWORST
metodÄ…
liniowego
prÃ³bkowania
Wyszukanie
Wstawienie
Usuwanie
Wyszukanie

Implementacja

AVG CASE
Wstawienie

AVG CASE
Usuwanie

PorÃ³wnanie
kluczy

Przeszukiwanie
sekwencyjne w tablicy
symboli (lista powiÄ…zana
nieuporzÄ…dkowana)

N

N

N

N/2

N

N/2

equals()

Przeszukiwanie binarne
w tablicy symboli
(tablica
uporzÄ…dkowana)

log N

N

N

log N

N/2

N/2

compareTo()

Drzewa wyszukiwaÅ„
binarnych

N

N

N

1.39 log N

1.39 log N

ğ‘

compareTo()

Drzewa 2-3
Czerwono-czarne BST

2 log N

2 log N

2 log N

1.00 log N

1.00 log N

1.00 log N

compareTo()

Haszowanie metodÄ…
Å‚aÅ„cuchowÄ…

N

N

N

3-5

3-5

3-5

Haszowanie metodÄ…
liniowego prÃ³bkowania

N

N

N

3-5

3-5

3-5

Podsumowanie

10


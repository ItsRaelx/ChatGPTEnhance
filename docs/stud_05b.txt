01.06.2023

Drzewa wyszukiwa≈Ñ binarnych
Drzewo wyszukiwa≈Ñ binarnych (ang. binary search tree - BST)
jest to drzewo binarne z symetrycznym porzƒÖdkiem.

Drzewo binarne:
‚Ä¢ Zawiera dwa roz≈ÇƒÖczne drzewa
binarne (lewe i prawe)
lub
‚Ä¢ Jest puste
[SW-2018]

Drzewa wyszukiwa≈Ñ binarnych
PorzƒÖdek symetryczny:
‚Ä¢ Ka≈ºdy wierzcho≈Çek zawiera klucz (+
implementacja Comparable)
‚Ä¢ Klucz w dowolnym wierzcho≈Çku jest:
‚Ä¢ Wiƒôkszy ni≈º wszystkie klucze w jego
lewym poddrzewie
‚Ä¢ Mniejszy ni≈º wszystkie klucze w jego
prawym poddrzewie

[SW-2018]

Drzewa wyszukiwa≈Ñ binarnych
Implementacja BST za pomocƒÖ
listy powiƒÖzanej
Node sk≈Çada siƒô z czterech p√≥l:
‚Ä¢ Key oraz Value
‚Ä¢ Referencjƒô do lewego i prawego
poddrzewa

public class BST {
private Node root;
private class Node {
private Key key;
private Value val;
private Node left, right;
} ...

}

[SW-2018]

1

01.06.2023

Drzewa wyszukiwa≈Ñ binarnych

public class BST<Key extends Comparable<Key>,
Value>

Implementacja BST za pomocƒÖ
listy powiƒÖzanej

{
private Node root;
private class Node {
‚Ä¶
}
public Value get(Key key) {
}
public void put(Key key, Value val) {
}
public void delete(Key key) {
}
}

Drzewa wyszukiwa≈Ñ binarnych
Operacja get()
Zwraca warto≈õƒá odpowiadajƒÖcƒÖ
danemu kluczowi, ew. zwraca
null, gdy nie znajdzie klucza.
Liczba por√≥wna≈Ñ wynosi:
1+g≈Çƒôboko≈õƒá drzewa (dok≈Çadniej
wierzcho≈Çka)

public Value get(Key key)
{
Node x = root;
while (x != null)
{
int cmp = key.compareTo(x.key);
if (cmp < 0) x = x.left;
else if (cmp > 0) x = x.right;
else if (cmp == 0) return x.val;
}
return null;
}

Drzewa wyszukiwa≈Ñ binarnych
Operacja put()
Wstawia parƒô (klucz, warto≈õƒá):
‚Ä¢ Gdy klucz istnieje w drzewie ‚Äì
nadpisz warto≈õƒá
‚Ä¢ Gdy klucz nie istnieje w drzewie
‚Äì dodaj nowy wierzcho≈Çek
Liczba por√≥wna≈Ñ wynosi:
1+g≈Çƒôboko≈õƒá drzewa
[SW-2018]

2

01.06.2023

Drzewa wyszukiwa≈Ñ binarnych
public void put(Key key, Value val)

Operacja put()
{
root = put(root, key, val);
Wstawia parƒô (klucz, warto≈õƒá):
}
‚Ä¢ Gdy klucz istnieje w drzewie ‚Äì private Node put(Node x, Key key, Value val)
nadpisz warto≈õƒá
{
if (x == null)
‚Ä¢ Gdy klucz nie istnieje w drzewie
return new Node(key, val);
int cmp = key.compareTo(x.key);
‚Äì dodaj nowy wierzcho≈Çek
if (cmp < 0)
x.left = put(x.left, key, val);
else if (cmp > 0)
x.right = put(x.right, key, val);
else
x.val = val;
return x;

Liczba por√≥wna≈Ñ wynosi:
1+g≈Çƒôboko≈õƒá drzewa
}

Drzewa wyszukiwa≈Ñ binarnych
Operacja deleteMin()
‚Ä¢ Schodzimy rekurencyjnie do
lewych poddrzew a≈º napotkamy
wierzcho≈Çek z referencjƒÖ do
lewego poddrzewa r√≥wnƒÖ null
‚Ä¢ ZastƒÖp tƒô referencjƒô referencjƒÖ
do jego prawego poddrzewa

public void deleteMin()
{
root = deleteMin(root);
}
private Node deleteMin(Node x)
{
if (x.left == null) return x.right;
x.left = deleteMin(x.left);
return x;
}

Drzewa wyszukiwa≈Ñ binarnych
Operacja delete()
Usuwa wierzcho≈Çek t o wskazanym
kluczu key
‚Ä¢ Znajd≈∫ ten wierzcho≈Çek
‚Ä¢ Usu≈Ñ go

3

01.06.2023

Drzewa wyszukiwa≈Ñ binarnych
Operacja delete()
Przypadek 1: Znaleziony wierzcho≈Çek t ma 0 potomk√≥w
‚Ä¢ Usu≈Ñ t przez ustawienie w wierzcho≈Çku przodka linku do tego drzewa
(wierzcho≈Çka) potomka na null

[SW-2018]

Drzewa wyszukiwa≈Ñ binarnych
Operacja delete()
Przypadek 2: Znaleziony wierzcho≈Çek t ma 1 potomka
‚Ä¢ Usu≈Ñ t przez przekierowanie w wierzcho≈Çku przodka linku do tego potomka
drzewa (wierzcho≈Çka) potomka na potomka usuwanego wierzcho≈Çka t

[SW-2018]

Drzewa wyszukiwa≈Ñ binarnych
Operacja delete()
Przypadek 3: Znaleziony wierzcho≈Çek
t ma 2 potomk√≥w
‚Ä¢ Znajd≈∫ nastƒôpnik x wierzcho≈Çka t
(nastƒôpnik ‚Äì wierzcho≈Çek o min
kluczu w prawym poddrzewie)
‚Ä¢ Usu≈Ñ min w prawym poddrzewie
wierzcho≈Çka t
‚Ä¢ Wstaw x w miejsce wierzcho≈Çka t

[SW-2018]

4

01.06.2023

Drzewa wyszukiwa≈Ñ
binarnych
Operacja delete()

public void delete(Key key){
root = delete(root, key);
}
private Node delete(Node x, Key key) {
if (x == null) return null;
int cmp = key.compareTo(x.key);
if (cmp < 0)
x.left = delete(x.left, key);
else if (cmp > 0)
x.right = delete(x.right, key);
else {
if (x.right == null) return x.left;
if (x.left == null) return x.right;
Node t = x;
x = min(t.right);
x.right = deleteMin(t.right);
x.left = t.left;
}
return x;
}

Drzewa wyszukiwa≈Ñ binarnych
Kszta≈Çt drzewa
‚Ä¢ Temu samemu zbiorowi kluczy odpowiada wiele drzew BST
‚Ä¢ Kszta≈Çt drzewa zale≈ºy od kolejno≈õci wstawiania element√≥w

[SW-2018]

‚Ä¢ Liczba por√≥wna≈Ñ dla operacji get()/put() wynosi 1+g≈Çƒôboko≈õƒá
drzewa

Drzewa wyszukiwa≈Ñ binarnych
Kszta≈Çt drzewa
Pomys≈Ç:
BudujƒÖc drzewo wstawiamy elementy w porzƒÖdku losowym ich
kluczy.
Konsekwencje:
Wyszukiwanie/wstawienie w drzewie zbudowanym z N losowych
kluczy wymaga ok. 1.39 log N por√≥wna≈Ñ ≈õrednio.

5

01.06.2023

Drzewa wyszukiwa≈Ñ binarnych
Implementacja pozosta≈Çych operacji
‚Ä¢ min(), max()
‚Ä¢ floor(), ceiling()
‚Ä¢ rank(), select(), size()
‚Ä¢ Iteracyjne przechodzenie po strukturze

Drzewa wyszukiwa≈Ñ binarnych
Implementacja pozosta≈Çych operacji
‚Ä¢ min() ‚Äì najmniejszy klucz w tablicy
‚Ä¢ max() ‚Äì najwiƒôkszy klucz w tablicy

[SW-2018]

Drzewa wyszukiwa≈Ñ binarnych
Implementacja pozosta≈Çych operacji
min() ‚Äì najmniejszy klucz w tablicy
Przypadek 1: Referencja w korzeniu do lewego
poddrzewa jest null
‚Ä¢ Funkcja zwraca warto≈õƒá klucza z korzenia
Przypadek 2: Referencja w korzeniu do lewego
poddrzewa nie jest null
‚Ä¢ Szukaj odpowiedzi w lewym poddrzewie
[SW-2018]

6

01.06.2023

Drzewa wyszukiwa≈Ñ binarnych
Implementacja pozosta≈Çych operacji
Przyk≈Çad
min()
Przypadek 1: Referencja w korzeniu do lewego
poddrzewa jest null
‚Ä¢ Funkcja zwraca warto≈õƒá klucza z korzenia

public Key min() {
return min(root).key;

private Node min(Node x) {
if (x.left == null)
return x;
else
return min(x.left);
}

Przypadek 2: Referencja w korzeniu do lewego
poddrzewa nie jest null
‚Ä¢ Szukaj odpowiedzi w lewym poddrzewie
[SW-2018]

Drzewa wyszukiwa≈Ñ binarnych
Implementacja pozosta≈Çych operacji
‚Ä¢ floor() ‚Äì najwiƒôkszy klucz
mniejszy lub r√≥wny danemu
kluczowi
‚Ä¢ ceiling() ‚Äì najmniejszy klucz
wiƒôkszy lub r√≥wny danemu kluczowi

public Key floor(Key key)
{
???
}
public Key ceiling(Key key)
{
???
}

[SW-2018]

Drzewa wyszukiwa≈Ñ binarnych
Implementacja pozosta≈Çych operacji
‚Ä¢ rank() ‚Äì zwraca liczbƒô kluczy mniejszych lub r√≥wnych k
‚Ä¢ select() ‚Äì zwraca klucz z pozycji (rank) k
‚Ä¢ size() ‚Äì zwraca liczbƒô wierzcho≈Çk√≥w

Jak efektywnie je zaimplementowaƒá?
Wskaz√≥wka: przypomnij sobie spos√≥b implementacji operacji
size() w strukturze kolejki czy stosu.

7

01.06.2023

Drzewa wyszukiwa≈Ñ binarnych
public class BST {
private Node root;

Implementacja pozosta≈Çych operacji
rank(), select(), size()
Jak efektywnie je zaimplementowaƒá?
W ka≈ºdym wierzcho≈Çku pamiƒôtamy liczbƒô
wierzcho≈Çk√≥w w poddrzewie, kt√≥rego
korzeniem jest ten wierzcho≈Çek.

private class Node {
private Key key;
private Value val;
private Node left, right;
private int count;
} ...
}

[SW-2018]

Drzewa wyszukiwa≈Ñ
binarnych
Implementacja pozosta≈Çych operacji
rank(), select(), size()

private Node put(Node x, Key key, Value
val)
{
if (x == null)
return new Node(key, val);
int cmp = key.compareTo(x.key);
if (cmp < 0)
x.left = put(x.left, key, val);
else if (cmp > 0)
x.right = put(x.right, key, val);
else
x.val = val;
x.count =
1 + size(x.left) + size(x.right);
return x;
}

Uwaga na operacje put() i delete()
w kontek≈õcie funkcji size()

Drzewa wyszukiwa≈Ñ
binarnych
Implementacja pozosta≈Çych operacji
Przyk≈Çad
rank() ‚Äì zwraca liczbƒô kluczy
mniejszych lub r√≥wnych k

public int rank(Key key) {
return rank(key, root);
}
private int rank(Key key, Node x)
{
if (x == null) return 0;
int cmp = key.compareTo(x.key);
if (cmp < 0)
return rank(key, x.left);
else if (cmp > 0)
return 1 + size(x.left) +
rank(key, x.right);
else
return size(x.left);
}

8

01.06.2023

Drzewa wyszukiwa≈Ñ binarnych
Implementacja pozosta≈Çych operacji
Iteracyjne przechodzenie po strukturze (porzƒÖdek INORDER):
‚Ä¢ Przejd≈∫ po lewym poddrzewie
‚Ä¢ Zapisz klucz do kolejki
‚Ä¢ Przejd≈∫ po prawym poddrzewie

Drzewa wyszukiwa≈Ñ binarnych
Implementacja pozosta≈Çych operacji public Iterable<Key> keys()
Iteracyjne przechodzenie po strukturze { Queue<Key> q = new Queue<Key>();
inorder(root, q);
(porzƒÖdek INORDER):
return q;
}
private void inorder(Node x,
Queue<Key> q)
{
if (x == null) return;
inorder(x.left, q);
q.enqueue(x.key);
inorder(x.right, q);
}

[SW-2018]

Przechodzenie w porzƒÖdku INORDER ustawia klucze w porzƒÖdku rosnƒÖcym.

Drzewa wyszukiwa≈Ñ binarnych
Metoda

Tablica symboli
nieuporzƒÖdkowana

Tablica symboli
uporzƒÖdkowana

Drzewo wyszukiwa≈Ñ
binarnych

search()

N

log N

h

insert()/delete()

N

N

h

min()/max()

N

1

h

floor()/ceiling()

N

log N

h

rank()

N

log N

h

select()

N

1

h
h ‚Äì wysoko≈õƒá drzewa
(proporcjonalna do log N)

9

01.06.2023

Drzewa wyszukiwa≈Ñ binarnych
Implementacja

WORST CASE
Wyszukanie

WORST CASE
Wstawienie

WORST CASE
Usuwanie

AVG CASE
Wyszukanie

AVG CASE
Wstawienie

AVG CASE
Usuwanie

Por√≥wnanie
kluczy

Przeszukiwanie
sekwencyjne w tablicy
symboli (lista powiƒÖzana
nieuporzƒÖdkowana)

N

N

N

N/2

N

N/2

equals()

Przeszukiwanie binarne
w tablicy symboli
(tablica
uporzƒÖdkowana)

log N

N

N

log N

N/2

N/2

compareTo()

Drzewa wyszukiwa≈Ñ
binarnych

N

N

N

1.39 log N

1.39 log N

ùëÅ

compareTo()

Drzewa wyszukiwa≈Ñ binarnych
Implementacja

WORST CASE
Wyszukanie

WORST CASE
Wstawienie

WORST CASE
Usuwanie

AVG CASE
Wyszukanie

AVG CASE
Wstawienie

AVG CASE
Usuwanie

Por√≥wnanie
kluczy

Przeszukiwanie
sekwencyjne w tablicy
symboli (lista powiƒÖzana
nieuporzƒÖdkowana)

N

N

N

N/2

N

N/2

equals()

Przeszukiwanie binarne
w tablicy symboli
(tablica
uporzƒÖdkowana)

log N

N

N

log N

N/2

N/2

compareTo()

1.39 log N

1.39 log N

ùëÅ

compareTo()

Drzewa wyszukiwa≈Ñ
binarnych

N

N

N

log N ?

log N ?

log N ?

Dalej: Szukamy mo≈ºliwo≈õci poprawienie najgorszego przypadku do log N?

10

